<html>
    <head>

    </head>
    <body>
        <div style="border-width: 3px; border-color : cyan ; border-style: solid; ">
            <h2>Threaded Binary Tree</h2>
            <b>Introduction :  </b>Inorder traversal of a Binary tree can either be done using recursion or with the use of a auxiliary stack. 
            The idea of threaded binary trees is to make inorder traversal faster and do it without stack and without recursion. 
            A binary tree is made threaded by making all right child pointers that would normally 
            be NULL point to the inorder successor of the node (if it exists).
        
            <img src="../images/threadedBT.png" border="2px" vspace ="20px" hspace = "20px" style="float: left;"><img>
        <h3>There are two types of threaded binary trees. </h3>
        <B>Single Threaded : </B> Where a NULL right pointers is made to point to the inorder successor (if successor exists)<br><br>
        <B>Double Threaded : </B> Where both left and right NULL pointers are made to point to inorder predecessor and inorder successor respectively. The predecessor threads are useful for reverse inorder traversal and postorder traversal.
        The threads are also useful for fast accessing ancestors of a node.
        Following diagram shows an example Single Threaded Binary Tree. The dotted lines represent threads. 

       <h3>Advantages of Threaded Binary Tree</h3> 
            <list>
                <ul>
                <li>In this Tree it enables linear traversal of elements.</li>
                <li>It eliminates the use of stack as it perform linear traversal.</li>
                <li>Enables to find parent node without explicit use of parent pointer</li>
                    Threaded tree give forward and backward traversal of nodes by in-order fashion</li>
                <li>Nodes contain pointers to in-order predecessor and successor</li>
                </ul>
            </list>
        
          <h2>  Threading</h2>
<p>"A binary tree is threaded by making all right child pointers that would normally be null point to the in-order successor of the node (if it exists), and all left child pointers that would normally be null point to the in-order predecessor of the node."[1]</p>

<p>This assumes the traversal order is the same as in-order traversal of the tree. However, pointers can instead (or in addition) be added to tree nodes, rather than replacing. Linked lists thus defined are also commonly called "threads", and can be used to enable traversal in any order(s) desired. For example, a tree whose nodes represent information about people might be sorted by name, but have extra threads allowing quick traversal in order of birth date, weight, or any other known characteristic.</p>

"A binary tree is threaded by making all right child pointers that would normally be null point to the in-order successor of the node (if it exists), and all left child pointers that would normally be null point to the in-order predecessor of the node."[1]

This assumes the traversal order is the same as in-order traversal of the tree. However, pointers can instead (or in addition) be added to tree nodes, rather than replacing. Linked lists thus defined are also commonly called "threads", and can be used to enable traversal in any order(s) desired. For example, a tree whose nodes represent information about people might be sorted by name, but have extra threads allowing quick traversal in order of birth date, weight, or any other known characteristic.
<img src="../images/threadedBT.png" border="2px" vspace ="20px" hspace = "20px" style="float: right;"><img>

<h3>Relation to parent pointers</h3>
Another way to achieve similar goals is to include a pointer in every node, to that node's parent node. Given that, the "next" node can always be reached. "right" pointers are still null whenever there are no right children. To find the "next" node from a node whose right pointer is null, walk up through "parent" pointers until reaching a node whose right pointer is not null, and is not the child you just came up from. That node is the "next" node, and after it come its descendants on the right.

It is also possible to discover the parent of a node from a threaded binary tree, without explicit use of parent pointers or a stack, although it is slower. To see this, consider a node k with right child r. Then the left pointer of r must be either a child or a thread back to k. In the case that r has a left child, that left child must in turn have either a left child of its own or a thread back to k, and so on for all successive left children. So by following the chain of left pointers from r, we will eventually find a thread pointing back to k. The situation is symmetrically similar when q is the left child of pâ€”we can follow q's right children to a thread pointing ahead to p.
<p>"A binary tree is threaded by making all right child pointers that would normally be null point to the in-order successor of the node (if it exists), and all left child pointers that would normally be null point to the in-order predecessor of the node."[1]</p>

<p>This assumes the traversal order is the same as in-order traversal of the tree. However, pointers can instead (or in addition) be added to tree nodes, rather than replacing. Linked lists thus defined are also commonly called "threads", and can be used to enable traversal in any order(s) desired. For example, a tree whose nodes represent information about people might be sorted by name, but have extra threads allowing quick traversal in order of birth date, weight, or any other known characteristic.</p>

        </div>
    </body>
</html>